const { createSprite } = require('./spriteUtils');

const BODY_TAG = '<body>';

/* eslint-disable no-param-reassign */
module.exports = class SvgSpriteHtmlWebpackPlugin {
  constructor() {
    this.svgList = [];
    this.lastCompiledList = this.svgList;
    this.svgSprite = '';

    this.pushSvg = this.pushSvg.bind(this);
    this.processSvg = this.processSvg.bind(this);
  }

  /**
 * Check if a svg file is already in a list of imported svg
 * @param {object} svgItem - svg to push in list of svg to compile
 * @param {string} svgItem.id
 * @param {string} svgItem.path
 * @return {boolean} true if svgItem is already in the list
 */
  isAlreadyInList(svgItem) {
    const svgItemIndex = this.svgList.findIndex(item => item.path === svgItem.path);
    return svgItemIndex >= 0;
  }

  /**
   * Add a svg to compile in this.svgList
   * we use spread syntax instead of array.prototype.push to check easier if the svgList change
   * @param {object} svgItem - svg to push in list of svg to compile
   * @param {string} svgItem.id
   * @param {string} svgItem.path
   */
  pushSvg(svgItem) {
    if (!this.isAlreadyInList(svgItem)) {
      this.svgList = [...this.svgList, svgItem];
    }
  }

  /**
   * Function called by webpack during compilation
   * @param {object} compiler - webpack compiler
   */
  apply(compiler) {
    compiler.plugin('compilation', (compilation) => {
      compilation.plugin('normal-module-loader', (loaderContext) => {
        // Give loader access to the list of svg to compile
        // Svg loader will push imported svg paths and ids
        if (!loaderContext.svgList) loaderContext.pushSvg = this.pushSvg;
      });

      compilation.plugin('html-webpack-plugin-before-html-processing', this.processSvg);
    });
  }

  /**
   * Inject svg sprite in the body of HTML string
   * @param {string} html - HTML string generated by HtmlWebpackPlugin
   * @return {string} html with svg sprite
   */
  insertSpriteInHtml(html) {
    const bodyElementIndex = html.indexOf(BODY_TAG) + BODY_TAG.length;
    const beforeBodyContent = html.slice(0, bodyElementIndex);
    const bodyContentAndEnd = html.slice(bodyElementIndex);
    const htmlWithSvg = beforeBodyContent + this.svgSprite + bodyContentAndEnd;
    return htmlWithSvg;
  }

  /**
   * Function called when HTML string is generated by HtmlWebpackPlugin
   * This function generate svg sprite with the list of svg collected by the svgLoader (./loader.js)
   * When the sprite is generated, it's injected in the HTML string
   * @param {object} htmlPluginData - object created by HtmlWebpackPlugin
   * @param {function} callback function to call when sprite creation and injection is finished
   */
  processSvg(htmlPluginData, callback) {
    const svgListChanged = this.svgList !== this.lastCompiledList;

    if (svgListChanged) {
      createSprite(this.svgList)
        .then((svgSprite) => {
          this.lastCompiledList = this.svgList;
          this.svgSprite = svgSprite;

          htmlPluginData.html = this.insertSpriteInHtml(htmlPluginData.html);
          callback(null, htmlPluginData);
        })
        .catch(console.error);
    } else {
      htmlPluginData.html = this.insertSpriteInHtml(htmlPluginData.html);
      callback(null, htmlPluginData);
    }
  }

  /**
   * Resolve the path of webpack loader to add in webpack configuration
   * @return {string} - the path of the svg loader
   */
  static getLoader() {
    return require.resolve('./loader.js');
  }
};
